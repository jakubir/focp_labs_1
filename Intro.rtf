{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red255\green255\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c0\c45600\c0;\csgenericrgb\c100000\c100000\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs30 \cf0 1. Command-line arguments
\f1\b0\fs24 \
\'95 A program may be called from a command line\
\'95 It may accept arguments (parameters)\
\'95 When main is called, it is called with (at least) two arguments:\
\'96 the number of arguments, including the program name itself;\
usually called argc, for argument count\
\'96 a pointer to an array of character strings containing arguments\
usually called argv, for argument vector\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b \cf0 int main(int argc, char *argv[])
\f1\b0 \
\'95 argv[0] is the name by which the program was invoked (argc is at least 1)\
If argc is 1, there are no arguments\
In the example:\
echo.exe hello, world \
\'95 argc is 3\
\'95 argv[0] is "echo.exe"\
\'95 argv[1] is "hello,"\
\'95 argv[2] is "world"\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs30 \cf0 2. Open/close files;
\f1\b0\fs24 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b \cf0 FILE *fp;\
FILE *fopen(char *name, char *mode);\
int fclose(FILE *fp)\

\f1\b0 \
FILE *fp = fopen(argv[1], "r");\
if(!fp)\
\{\
	printf("Error");\
	getchar();\
	return 0;\
\}\
fclose(fp);\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs30 \cf0 3. Read/write files\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\b0\fs24 \cf0 \

\f0\b 1. single byte\
\
int getc(FILE *fp)
\f1\b0 \
returns EOF for end of file or error after failing to read\

\f0\b int putc(int c, FILE *fp)\

\f1\b0 putc writes the character c to the file fp and returns the\
character written, or EOF if an error occurs\

\f0\b \
2. formatted input\

\f1\b0 \

\f0\b int fscanf(FILE *fp, char *format, ...)\
int fprintf(FILE *fp, char *format, ...)\
\
int feof( FILE *stream );
\f1\b0 \
\'95 It returns 0 if the current position is not end of file\

\f0\b \
3. unformatted input\
\
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );\
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
\f2\b0\fs26 \cf2 \cb3 \
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\f0\b\fs30 \cf0 \cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 4.  File pointer operations\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf0 \
long ftell( FILE *stream); \

\f1\b0 gets the current position of the file pointer\
\'95 result: relative to the beginning of the streamint \
\

\f0\b fseek( FILE *stream, long offset, int origin );\

\f1\b0 - moves the file pointer to a new location that is offset bytes from origin\
\'95 The next operation takes place at the new location\
\'95 On a stream open for update, the next operation can be either a read or a write\
origin:\
 SEEK_SET	Beginning of file\
 SEEK_CUR	Current position of the file pointer\
 SEEK_END	End of file\
\

\f0\b void rewind ( FILE * stream );
\f1\b0 \
sets the file position to the beginning of the file of the given stream\
}